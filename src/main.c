/*
 * Copyright (c) 2015 Przemys≈Çaw Kusiak <primo@poczta.fm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "partclone.h"
#include "options.h"
#include "log.h"
#include "initialization.h"
#include "nbd.h"

#include <argp.h>
#include <stdlib.h>
#include <string.h>

// God's number: 543632

const char *argp_program_version = "partclone.nbd-server v0.0.1";
const char *argp_program_bug_address = "<primo@poczta.fm>";

// Program documentation.
static char doc[] =
"Use partclone images as NBD exports.\
\
\v\
\
Detalied descriptions of all options are available in the manual.\n\
\n\
Default log file: /var/log/partclone.nbd-server.\n"
//"\n\
//Default configuration file: /etc/nbd-server/partclone-nbd-config. If it doesn't exist it will be \
//autogenerated from /etc/nbd-sever/config or created from template. Details in manual."
;

// A description of the arguments we accept.
static char args_doc[] = "port partclone_image";

// The options we understand.
static struct argp_option options_for_argp[] = {
// -------------------------------------------------------------------------------------------------------------------
//  {0,0,0,0, "NBD options:", -2 },
// -------------------------------------------------------------------------------------------------------------------
//  {"config-file",       'c', "FILE",        0,                      "Specify an alternate configuration file."         },
//  {"authorize-file",    'l', "FILE",        0,                      "File with list of hosts that are allowed to "
//                                                                    "connect (details in manual)."                     },
//  {"pid-file",          'p', "FILE",        0,                      "Specify a filename to write our PID to."          },
//  {"max-connections",   'M', "NUM",         0,                      "Specify a maximum number of opened connections."  },
// -------------------------------------------------------------------------------------------------------------------
  {0,0,0,0, "image options:", -3},
// -------------------------------------------------------------------------------------------------------------------
  {"elems-per-cache",   'x', "NUM",         0,                      "Specify a number of bitmap elements per one cache "
                                                                    "element (default: 512). Higher value means better "
                                                                    "performance, but more RAM is consumed. Must be a "
                                                                    "power of two. Details in manual."                 },
//  {"check-crc",         'C', "y|n",         OPTION_ARG_OPTIONAL,    "Check crc checksum before each used blocks and "
//                                                                    "header. For 0001 images disabled by default "
//                                                                    "because of damaged checksum algorithm which "
//                                                                    "calculate the first byte over and over again."    },
//  {"swap-endianness",   'e', 0,             0,                      "Use when endianness of your machine is different "
//                                                                    "than endianness of machine on which this image was "
//                                                                    "created. Used only for 0001 images. 0002 images "
//                                                                    "contain information about endianness, therefore "
//                                                                    "this parameter is ignored for them. "             },
// -------------------------------------------------------------------------------------------------------------------
  {0,0,0,0, "global options:", -1 },
// -------------------------------------------------------------------------------------------------------------------
  {"log-file",          'L', "FILE",        0,                      "Specify an alternative path for a log file."      },
  {"quiet",             'q', 0,             0,                      "Do not print debug messages."                     },
  {"silent",            's', 0,             OPTION_ALIAS,           0                                                  },

  { 0 }
};

// Parse a single option.
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
    struct options *options = state->input;

    switch(key) {
    case 'q': case 's':
        SET_OPTION(options, quiet, 1);
        break;
    case 'L':
        SET_OPTION(options, log_file, arg);
        break;
//    case 'l':
//        SET_OPTION(options, auth_file, arg);
//        break;
//    case 'p':
//        SET_OPTION(options, pid_file, arg);
//        break;
//    case 'M':
//        SET_OPTION(options, max_connections, atoll(arg));
//        break;
//    case 'c':
//        SET_OPTION(options, cfg_file, arg);
//        break;
    case 'x':
        SET_OPTION(options, elems_per_cache, atoll(arg));
        break;
//    case 'C':
//        SET_OPTION(options, check_crc, (*arg == 'n' || *arg == '0') ? 0 : 1);
//        break;
//    case 'e':
//        SET_OPTION(options, different_endianness, 1);
//        break;

    case ARGP_KEY_ARG:

        switch (options->arguments_left)
        {
        case 0:
            argp_error(state, "Too many arguments.");

        case 1:
            SET_OPTION(options, image_path, arg);
            break;

        case 2:
//            if(strncpy(arg, "ip:", 3) == 0) {
//                SET_OPTION(options, ip6, 0);
//            } else if(strncpy(arg, "ip@", 3) == 0) {
//                SET_OPTION(options, ip6, 1);
//            }

//            if(options->ip6.set_by_user == 1) {
//                SET_OPTION(options, port, atoi(arg + 3));
//            } else {
                SET_OPTION(options, port, atoi(arg));
//            }
            break;
        }

        options->arguments_left--;

        break;

    case ARGP_KEY_END:

        if(options->port.set_by_user == 0) {
            argp_error(state, "You must specify a port.");
        }

        if(options->image_path.set_by_user == 0) {
            argp_error(state, "You must specify an image path.");
        }


    default:
        return ARGP_ERR_UNKNOWN;
    }

    return 0;
}

int main(int argc, char **argv)
{
    struct options options = { 0 };

    options.arguments_left = 2;
    options.log_file.v = "partclone-nbd.log";
//    options.auth_file.v = "partclone-nbd.auth";
//    options.cfg_file.v = "partclone-nbd.cfg";
//    options.pid_file.v = "partclone-nbd.pid";
    options.elems_per_cache.v = 512;

    struct argp argp = { options_for_argp, parse_opt, args_doc, doc };
    argp_parse (&argp, argc, argv, 0, 0, &options);

    struct image img;

    if(initialize_log(&options) == error) goto error_1;
    if(load_image(&img, &options) == error) goto error_2;
    if(start_server(&img, &options) == error) goto error_3;
    if(close_image(&img) == error) goto error_2;
    if(close_log() == error) goto error_1;

    log_debug("Closing program with status 0.");
    return (int) ok;

error_3:
    close_image(&img);

error_2:
    close_log();

error_1:
    log_error("Errors occured - see log file for details.");
    return (int) error;
}
